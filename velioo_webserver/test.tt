0.00 async_server.py(1): import sys
0.01 async_server.py(2): import os
0.01 async_server.py(3): sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
0.01 async_server.py(4): import errno
0.01 async_server.py(5): import socket
0.27 <frozen importlib._bootstrap>(177): 0.27 <frozen importlib._bootstrap>(178): 0.27 <frozen importlib._bootstrap>(182): 0.27 <frozen importlib._bootstrap>(183): 0.27 <frozen importlib._bootstrap>(185): 0.27 async_server.py(6): import subprocess
0.40 <frozen importlib._bootstrap>(177): 0.40 <frozen importlib._bootstrap>(178): 0.40 <frozen importlib._bootstrap>(182): 0.40 <frozen importlib._bootstrap>(183): 0.40 <frozen importlib._bootstrap>(185): 0.40 async_server.py(7): import signal
0.40 async_server.py(8): import traceback
0.40 async_server.py(9): import datetime
0.44 <frozen importlib._bootstrap>(177): 0.44 <frozen importlib._bootstrap>(178): 0.44 <frozen importlib._bootstrap>(182): 0.44 <frozen importlib._bootstrap>(183): 0.44 <frozen importlib._bootstrap>(185): 0.44 async_server.py(10): import select
0.44 async_server.py(11): import aiofiles
1.84 <frozen importlib._bootstrap>(177): 1.84 <frozen importlib._bootstrap>(178): 1.84 <frozen importlib._bootstrap>(182): 1.84 <frozen importlib._bootstrap>(183): 1.84 <frozen importlib._bootstrap>(185): 1.84 async_server.py(12): import time
1.84 async_server.py(13): from time import mktime
1.84 <frozen importlib._bootstrap>(1007): 1.84 <frozen importlib._bootstrap>(1025): 1.84 async_server.py(14): from wsgiref.handlers import format_date_time
1.93 <frozen importlib._bootstrap>(1007): 1.93 <frozen importlib._bootstrap>(1025): 1.93 async_server.py(15): from pathlib import Path
2.10 <frozen importlib._bootstrap>(1007): 2.10 <frozen importlib._bootstrap>(1025): 2.10 async_server.py(16): import resource
2.11 <frozen importlib._bootstrap>(177): 2.11 <frozen importlib._bootstrap>(178): 2.11 <frozen importlib._bootstrap>(182): 2.11 <frozen importlib._bootstrap>(183): 2.11 <frozen importlib._bootstrap>(185): 2.11 async_server.py(17): import logging
2.11 async_server.py(18): import velioo_webserver.config.environment as env
2.14 <frozen importlib._bootstrap>(177): 2.14 <frozen importlib._bootstrap>(178): 2.14 <frozen importlib._bootstrap>(182): 2.14 <frozen importlib._bootstrap>(183): 2.14 <frozen importlib._bootstrap>(185): 2.14 async_server.py(19): import asyncio
2.14 async_server.py(20): from async_logging_handler import AsyncFileHandler
2.17 <frozen importlib._bootstrap>(1007): 2.17 <frozen importlib._bootstrap>(1008): 2.17 <frozen importlib._bootstrap>(1013): 2.17 <frozen importlib._bootstrap>(1014): 2.17 <frozen importlib._bootstrap>(1013): 2.17 <frozen importlib._bootstrap>(1025): 2.17 async_server.py(21): import mimetypes
2.20 <frozen importlib._bootstrap>(177): 2.20 <frozen importlib._bootstrap>(178): 2.20 <frozen importlib._bootstrap>(182): 2.20 <frozen importlib._bootstrap>(183): 2.20 <frozen importlib._bootstrap>(185): 2.20 async_server.py(23): now = datetime.datetime.now()
2.20 async_server.py(24): async_handler = AsyncFileHandler('logs/async_server_' + now.strftime("%Y-%m-%d") + '.log')
2.24 async_server.py(25): logging.basicConfig(level=logging.ERROR, format='%(levelname)s:%(asctime)s --> %(message)s', datefmt='%m/%d/%Y %H:%M:%S', handlers=[async_handler])
2.24 async_server.py(27): def serve_forever():
2.24 async_server.py(52): def grim_reaper(signum, frame):
2.24 async_server.py(63): async def handle_request(client_reader, client_writer):
2.24 async_server.py(440): async def send_static_file(path, client_writer):
2.24 async_server.py(453): def convert_path(path):
2.24 async_server.py(460): def set_environment(*args, **kwargs):
2.24 async_server.py(471): def get_current_gmt_time():
2.24 async_server.py(477): def get_server_name():
2.24 async_server.py(481): def get_server_software():
2.24 async_server.py(485): def send_response_400(client_writer):
2.24 async_server.py(492): def send_response_403(client_writer):
2.24 async_server.py(499): def send_response_404(client_writer):
2.24 async_server.py(506): def send_response_408(client_writer):
2.24 async_server.py(513): def send_response_411(client_writer):
2.24 async_server.py(520): def send_response_500(client_writer):
2.24 async_server.py(527): def send_response_501(client_writer):
2.24 async_server.py(534): if __name__ == '__main__':
2.24 async_server.py(535):     try:
2.24 async_server.py(536):         serve_forever()
2.24 async_server.py(28):     print('Starting server...')
2.24 async_server.py(29):     loop = asyncio.get_event_loop()
2.25 async_server.py(30):     coroutine = asyncio.start_server(handle_request, host=os.environ.get('SERVER_NAME', 'localhost'), 
2.25 async_server.py(31):                                    port=os.environ.get('ALT_PORT', 8888),
2.25 async_server.py(32):                                    backlog=env.REQUEST_QUEUE_SIZE,
2.25 async_server.py(33):                                    family=env.ADDRESS_FAMILY, 
2.25 async_server.py(34):                                    reuse_address=True)
2.25 async_server.py(35):     loop.run_until_complete(coroutine)
2.26 async_server.py(36):     loop.add_signal_handler(signal.SIGCHLD, grim_reaper)
2.26 async_server.py(37):     os.environ['SERVER_TYPE'] = 'ASYNC'
2.26 async_server.py(38):     try:
2.26 async_server.py(39):         resource.setrlimit(resource.RLIMIT_NOFILE, (65536, 65536))
2.26 async_server.py(43):     while True:
2.26 async_server.py(44):         try:
2.26 async_server.py(45):             loop.run_forever()
3.21 async_server.py(64):     logging.info('handle_request invoked...')
3.21 async_server.py(65):     arguments = ""
3.21 async_server.py(66):     try:
3.21 async_server.py(67):         logging.info('Receiving request...')
3.21 async_server.py(68):         request_headers = b''
3.21 async_server.py(69):         request_body = b''
3.21 async_server.py(70):         method, path, protocol = '', '', ''
3.21 async_server.py(71):         data = b''
3.21 async_server.py(72):         try:
3.21 async_server.py(73):             timeout = time.time() + 10
3.21 async_server.py(74):             while True:
3.21 async_server.py(75):                 logging.info('Reading data...')
3.21 async_server.py(76):                 try:
3.21 async_server.py(77):                     data = await asyncio.wait_for(client_reader.read(env.RECV_BUFSIZE), 10.0)
3.23 async_server.py(64):     logging.info('handle_request invoked...')
3.23 async_server.py(65):     arguments = ""
3.23 async_server.py(66):     try:
3.23 async_server.py(67):         logging.info('Receiving request...')
3.23 async_server.py(68):         request_headers = b''
3.23 async_server.py(69):         request_body = b''
3.23 async_server.py(70):         method, path, protocol = '', '', ''
3.23 async_server.py(71):         data = b''
3.23 async_server.py(72):         try:
3.23 async_server.py(73):             timeout = time.time() + 10
3.23 async_server.py(74):             while True:
3.23 async_server.py(75):                 logging.info('Reading data...')
3.23 async_server.py(76):                 try:
3.23 async_server.py(77):                     data = await asyncio.wait_for(client_reader.read(env.RECV_BUFSIZE), 10.0)
3.23 async_server.py(64):     logging.info('handle_request invoked...')
3.23 async_server.py(65):     arguments = ""
3.23 async_server.py(66):     try:
3.23 async_server.py(67):         logging.info('Receiving request...')
3.23 async_server.py(68):         request_headers = b''
3.23 async_server.py(69):         request_body = b''
3.23 async_server.py(70):         method, path, protocol = '', '', ''
3.23 async_server.py(71):         data = b''
3.23 async_server.py(72):         try:
3.23 async_server.py(73):             timeout = time.time() + 10
3.23 async_server.py(74):             while True:
3.23 async_server.py(75):                 logging.info('Reading data...')
3.23 async_server.py(76):                 try:
3.23 async_server.py(77):                     data = await asyncio.wait_for(client_reader.read(env.RECV_BUFSIZE), 10.0)
3.24 async_server.py(82):                 try:
3.24 async_server.py(83):                     if time.time() > timeout:
3.24 async_server.py(89):                 if data != b'':
3.24 async_server.py(90):                     logging.info('Data read: {}'.format(data))
3.24 async_server.py(91):                     try:
3.24 async_server.py(92):                         request_headers+=data
3.24 async_server.py(98):                     try:
3.24 async_server.py(99):                         if b'\r\n' in request_headers and not method:
3.24 async_server.py(100):                             method, path, protocol = request_headers.split(b'\r\n')[0].decode('utf-8').strip().split(" ")
3.24 async_server.py(101):                         if b'\r\n\r\n' in request_headers:
3.24 async_server.py(102):                             temp = request_headers
3.24 async_server.py(103):                             request_headers = request_headers.split(b'\r\n\r\n')[0].decode('utf-8') + '\r\n\r\n'
3.24 async_server.py(104):                             if method == 'POST':
3.24 async_server.py(111):                             break
3.24 async_server.py(126):         logging.info('Request headers:\n{}'.format(request_headers))
3.24 async_server.py(127):         if request_headers == b'':
3.24 async_server.py(131):         if '\r\n\r\n' not in request_headers:
3.24 async_server.py(135):         headers = {}
3.24 async_server.py(136):         try:
3.24 async_server.py(137):             splitted_headers = request_headers.split('\r\n')
3.24 async_server.py(138):             for header in splitted_headers:
3.24 async_server.py(139):                 if ':' in header:
3.24 async_server.py(138):             for header in splitted_headers:
3.24 async_server.py(139):                 if ':' in header:
3.24 async_server.py(140):                     splitted_header = header.split(":", 1)
3.24 async_server.py(141):                     if len(splitted_header) > 1:
3.24 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
3.24 async_server.py(138):             for header in splitted_headers:
3.24 async_server.py(139):                 if ':' in header:
3.24 async_server.py(140):                     splitted_header = header.split(":", 1)
3.24 async_server.py(141):                     if len(splitted_header) > 1:
3.24 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
3.24 async_server.py(138):             for header in splitted_headers:
3.24 async_server.py(139):                 if ':' in header:
3.24 async_server.py(140):                     splitted_header = header.split(":", 1)
3.24 async_server.py(141):                     if len(splitted_header) > 1:
3.24 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
3.24 async_server.py(138):             for header in splitted_headers:
3.24 async_server.py(139):                 if ':' in header:
3.24 async_server.py(140):                     splitted_header = header.split(":", 1)
3.24 async_server.py(141):                     if len(splitted_header) > 1:
3.24 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
3.24 async_server.py(138):             for header in splitted_headers:
3.24 async_server.py(139):                 if ':' in header:
3.24 async_server.py(140):                     splitted_header = header.split(":", 1)
3.24 async_server.py(141):                     if len(splitted_header) > 1:
3.24 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
3.24 async_server.py(138):             for header in splitted_headers:
3.24 async_server.py(139):                 if ':' in header:
3.24 async_server.py(140):                     splitted_header = header.split(":", 1)
3.24 async_server.py(141):                     if len(splitted_header) > 1:
3.24 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
3.24 async_server.py(138):             for header in splitted_headers:
3.24 async_server.py(139):                 if ':' in header:
3.24 async_server.py(140):                     splitted_header = header.split(":", 1)
3.24 async_server.py(141):                     if len(splitted_header) > 1:
3.24 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
3.24 async_server.py(138):             for header in splitted_headers:
3.24 async_server.py(139):                 if ':' in header:
3.24 async_server.py(140):                     splitted_header = header.split(":", 1)
3.24 async_server.py(141):                     if len(splitted_header) > 1:
3.24 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
3.24 async_server.py(138):             for header in splitted_headers:
3.24 async_server.py(139):                 if ':' in header:
3.24 async_server.py(140):                     splitted_header = header.split(":", 1)
3.24 async_server.py(141):                     if len(splitted_header) > 1:
3.24 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
3.24 async_server.py(138):             for header in splitted_headers:
3.24 async_server.py(139):                 if ':' in header:
3.24 async_server.py(138):             for header in splitted_headers:
3.24 async_server.py(139):                 if ':' in header:
3.24 async_server.py(138):             for header in splitted_headers:
3.24 async_server.py(149):         if method == 'GET':
3.24 async_server.py(150):             logging.info('Request method is GET')
3.24 async_server.py(205):         if '?' in path:
3.24 async_server.py(213):         logging.info('Converting path: {} to Path object...'.format(path))
3.24 async_server.py(214):         path = convert_path(path)
3.24 async_server.py(454):     if isinstance(path, str):
3.24 async_server.py(455):         return Path("./{path}".format(path=path))
3.24 async_server.py(215):         if path.exists():
3.24 async_server.py(216):             path_str = str(path)
3.24 async_server.py(217):             logging.info('Checking if {} is forbidden...'.format(path_str))
3.24 async_server.py(218):             path_is_allowed = False
3.24 async_server.py(219):             for p in env.allowed_dirs:
3.24 async_server.py(220):                 if path_str.startswith(p):
3.24 async_server.py(221):                     path_is_allowed = True
3.24 async_server.py(222):                     break
3.24 async_server.py(223):             if not path_is_allowed:      
3.24 async_server.py(228):             if path_is_allowed:        
3.24 async_server.py(229):                 if path.is_file() or path.is_dir():
3.24 async_server.py(230):                     if path.is_dir():
3.24 async_server.py(231):                         try:
3.24 async_server.py(232):                             path = convert_path(path_str + "/index.html")
3.24 async_server.py(454):     if isinstance(path, str):
3.24 async_server.py(455):         return Path("./{path}".format(path=path))
3.24 async_server.py(242):                         path_str = str(path)
3.24 async_server.py(243):                         logging.info('Path is a directory. Changing path to {}'.format(path))
3.24 async_server.py(244):                     if path.is_file():
3.24 async_server.py(245):                         logging.info('Path is a file')
3.24 async_server.py(246):                         if path_str.startswith("cgi-bin") and os.access(path_str, os.X_OK):
3.24 async_server.py(379):                             logging.info('Path is a resource. Guessing MIME type...')
3.24 async_server.py(380):                             try:
3.24 async_server.py(381):                                 mime = mimetypes.guess_type(path_str, False)[0]
3.50 async_server.py(382):                                 if mime == None:
3.50 async_server.py(388):                             logging.info('MIME: {}'.format(mime))
3.50 async_server.py(398):                                             + b"\r\n\r\n"
3.50 async_server.py(472):     now = datetime.datetime.now()
3.50 async_server.py(473):     stamp = mktime(now.timetuple())
3.50 async_server.py(474):     return format_date_time(stamp).encode()
3.50 async_server.py(482):     return os.environ.get('SERVER_SOFTWARE', "Velioo's Webserver").encode()
3.50 async_server.py(400):                             logging.info('Response:\n{}'.format(http_response.decode()))
3.50 async_server.py(401):                             client_writer.write(http_response)
3.50 async_server.py(402):                             try:
3.50 async_server.py(403):                                 await send_static_file(path, client_writer)
3.50 async_server.py(441):     timeout = time.time() + 10
3.50 async_server.py(442):     async with aiofiles.open(path, 'rb') as f:
3.52 async_server.py(443):         while True:
3.52 async_server.py(444):             chunk = await f.read(env.FILE_CHUNK)
3.53 async_server.py(445):             if not chunk:
3.53 async_server.py(447):             client_writer.write(chunk)
3.53 async_server.py(448):             await client_writer.drain()
3.53 async_server.py(449):             if time.time() > timeout:
3.53 async_server.py(444):             chunk = await f.read(env.FILE_CHUNK)
3.56 async_server.py(445):             if not chunk:
3.56 async_server.py(446):                 break
3.57 async_server.py(406):                             client_writer.close()
3.58 async_server.py(82):                 try:
3.58 async_server.py(83):                     if time.time() > timeout:
3.58 async_server.py(89):                 if data != b'':
3.58 async_server.py(90):                     logging.info('Data read: {}'.format(data))
3.58 async_server.py(91):                     try:
3.58 async_server.py(92):                         request_headers+=data
3.58 async_server.py(98):                     try:
3.58 async_server.py(99):                         if b'\r\n' in request_headers and not method:
3.58 async_server.py(100):                             method, path, protocol = request_headers.split(b'\r\n')[0].decode('utf-8').strip().split(" ")
3.58 async_server.py(101):                         if b'\r\n\r\n' in request_headers:
3.58 async_server.py(102):                             temp = request_headers
3.58 async_server.py(103):                             request_headers = request_headers.split(b'\r\n\r\n')[0].decode('utf-8') + '\r\n\r\n'
3.58 async_server.py(104):                             if method == 'POST':
3.58 async_server.py(111):                             break
3.58 async_server.py(126):         logging.info('Request headers:\n{}'.format(request_headers))
3.58 async_server.py(127):         if request_headers == b'':
3.58 async_server.py(131):         if '\r\n\r\n' not in request_headers:
3.58 async_server.py(135):         headers = {}
3.58 async_server.py(136):         try:
3.58 async_server.py(137):             splitted_headers = request_headers.split('\r\n')
3.58 async_server.py(138):             for header in splitted_headers:
3.58 async_server.py(139):                 if ':' in header:
3.58 async_server.py(138):             for header in splitted_headers:
3.58 async_server.py(139):                 if ':' in header:
3.58 async_server.py(140):                     splitted_header = header.split(":", 1)
3.58 async_server.py(141):                     if len(splitted_header) > 1:
3.58 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
3.58 async_server.py(138):             for header in splitted_headers:
3.58 async_server.py(139):                 if ':' in header:
3.58 async_server.py(140):                     splitted_header = header.split(":", 1)
3.58 async_server.py(141):                     if len(splitted_header) > 1:
3.58 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
3.58 async_server.py(138):             for header in splitted_headers:
3.58 async_server.py(139):                 if ':' in header:
3.58 async_server.py(140):                     splitted_header = header.split(":", 1)
3.58 async_server.py(141):                     if len(splitted_header) > 1:
3.58 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
3.58 async_server.py(138):             for header in splitted_headers:
3.58 async_server.py(139):                 if ':' in header:
3.58 async_server.py(140):                     splitted_header = header.split(":", 1)
3.58 async_server.py(141):                     if len(splitted_header) > 1:
3.58 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
3.58 async_server.py(138):             for header in splitted_headers:
3.58 async_server.py(139):                 if ':' in header:
3.58 async_server.py(140):                     splitted_header = header.split(":", 1)
3.58 async_server.py(141):                     if len(splitted_header) > 1:
3.58 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
3.58 async_server.py(138):             for header in splitted_headers:
3.58 async_server.py(139):                 if ':' in header:
3.58 async_server.py(140):                     splitted_header = header.split(":", 1)
3.58 async_server.py(141):                     if len(splitted_header) > 1:
3.58 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
3.58 async_server.py(138):             for header in splitted_headers:
3.58 async_server.py(139):                 if ':' in header:
3.58 async_server.py(140):                     splitted_header = header.split(":", 1)
3.58 async_server.py(141):                     if len(splitted_header) > 1:
3.58 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
3.58 async_server.py(138):             for header in splitted_headers:
3.58 async_server.py(139):                 if ':' in header:
3.58 async_server.py(140):                     splitted_header = header.split(":", 1)
3.58 async_server.py(141):                     if len(splitted_header) > 1:
3.58 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
3.58 async_server.py(138):             for header in splitted_headers:
3.58 async_server.py(139):                 if ':' in header:
3.58 async_server.py(140):                     splitted_header = header.split(":", 1)
3.58 async_server.py(141):                     if len(splitted_header) > 1:
3.58 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
3.58 async_server.py(138):             for header in splitted_headers:
3.58 async_server.py(139):                 if ':' in header:
3.58 async_server.py(138):             for header in splitted_headers:
3.58 async_server.py(139):                 if ':' in header:
3.58 async_server.py(138):             for header in splitted_headers:
3.58 async_server.py(149):         if method == 'GET':
3.58 async_server.py(150):             logging.info('Request method is GET')
3.58 async_server.py(205):         if '?' in path:
3.58 async_server.py(213):         logging.info('Converting path: {} to Path object...'.format(path))
3.58 async_server.py(214):         path = convert_path(path)
3.58 async_server.py(454):     if isinstance(path, str):
3.58 async_server.py(455):         return Path("./{path}".format(path=path))
3.58 async_server.py(215):         if path.exists():
3.58 async_server.py(416):             logging.info('Path doesn\'t exist')
3.58 async_server.py(417):             send_response_404(client_writer)
3.58 async_server.py(500):     http_response = b"HTTP/1.1 404 Not Found\r\nDate: " + get_current_gmt_time() + b"\r\nServer: " + get_server_software() + b"\r\n\r\nError 404 \r\nResource not found"
3.58 async_server.py(472):     now = datetime.datetime.now()
3.58 async_server.py(473):     stamp = mktime(now.timetuple())
3.58 async_server.py(474):     return format_date_time(stamp).encode()
3.58 async_server.py(482):     return os.environ.get('SERVER_SOFTWARE', "Velioo's Webserver").encode()
3.58 async_server.py(501):     logging.info('Response:{}\n'.format(http_response.decode()))
3.58 async_server.py(502):     client_writer.write(http_response)
3.58 async_server.py(503):     client_writer.close()
5.18 async_server.py(64):     logging.info('handle_request invoked...')
5.19 async_server.py(65):     arguments = ""
5.19 async_server.py(66):     try:
5.19 async_server.py(67):         logging.info('Receiving request...')
5.19 async_server.py(68):         request_headers = b''
5.19 async_server.py(69):         request_body = b''
5.19 async_server.py(70):         method, path, protocol = '', '', ''
5.19 async_server.py(71):         data = b''
5.19 async_server.py(72):         try:
5.19 async_server.py(73):             timeout = time.time() + 10
5.19 async_server.py(74):             while True:
5.19 async_server.py(75):                 logging.info('Reading data...')
5.19 async_server.py(76):                 try:
5.19 async_server.py(77):                     data = await asyncio.wait_for(client_reader.read(env.RECV_BUFSIZE), 10.0)
5.19 async_server.py(64):     logging.info('handle_request invoked...')
5.19 async_server.py(65):     arguments = ""
5.19 async_server.py(66):     try:
5.19 async_server.py(67):         logging.info('Receiving request...')
5.19 async_server.py(68):         request_headers = b''
5.19 async_server.py(69):         request_body = b''
5.19 async_server.py(70):         method, path, protocol = '', '', ''
5.19 async_server.py(71):         data = b''
5.19 async_server.py(72):         try:
5.19 async_server.py(73):             timeout = time.time() + 10
5.19 async_server.py(74):             while True:
5.19 async_server.py(75):                 logging.info('Reading data...')
5.19 async_server.py(76):                 try:
5.19 async_server.py(77):                     data = await asyncio.wait_for(client_reader.read(env.RECV_BUFSIZE), 10.0)
5.19 async_server.py(82):                 try:
5.19 async_server.py(83):                     if time.time() > timeout:
5.19 async_server.py(89):                 if data != b'':
5.19 async_server.py(90):                     logging.info('Data read: {}'.format(data))
5.19 async_server.py(91):                     try:
5.19 async_server.py(92):                         request_headers+=data
5.19 async_server.py(98):                     try:
5.19 async_server.py(99):                         if b'\r\n' in request_headers and not method:
5.19 async_server.py(100):                             method, path, protocol = request_headers.split(b'\r\n')[0].decode('utf-8').strip().split(" ")
5.19 async_server.py(101):                         if b'\r\n\r\n' in request_headers:
5.19 async_server.py(102):                             temp = request_headers
5.19 async_server.py(103):                             request_headers = request_headers.split(b'\r\n\r\n')[0].decode('utf-8') + '\r\n\r\n'
5.19 async_server.py(104):                             if method == 'POST':
5.19 async_server.py(111):                             break
5.19 async_server.py(126):         logging.info('Request headers:\n{}'.format(request_headers))
5.19 async_server.py(127):         if request_headers == b'':
5.19 async_server.py(131):         if '\r\n\r\n' not in request_headers:
5.19 async_server.py(135):         headers = {}
5.19 async_server.py(136):         try:
5.19 async_server.py(137):             splitted_headers = request_headers.split('\r\n')
5.19 async_server.py(138):             for header in splitted_headers:
5.19 async_server.py(139):                 if ':' in header:
5.19 async_server.py(138):             for header in splitted_headers:
5.19 async_server.py(139):                 if ':' in header:
5.19 async_server.py(140):                     splitted_header = header.split(":", 1)
5.19 async_server.py(141):                     if len(splitted_header) > 1:
5.19 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
5.19 async_server.py(138):             for header in splitted_headers:
5.19 async_server.py(139):                 if ':' in header:
5.19 async_server.py(140):                     splitted_header = header.split(":", 1)
5.19 async_server.py(141):                     if len(splitted_header) > 1:
5.19 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
5.19 async_server.py(138):             for header in splitted_headers:
5.19 async_server.py(139):                 if ':' in header:
5.19 async_server.py(140):                     splitted_header = header.split(":", 1)
5.19 async_server.py(141):                     if len(splitted_header) > 1:
5.19 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
5.19 async_server.py(138):             for header in splitted_headers:
5.19 async_server.py(139):                 if ':' in header:
5.19 async_server.py(140):                     splitted_header = header.split(":", 1)
5.19 async_server.py(141):                     if len(splitted_header) > 1:
5.19 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
5.19 async_server.py(138):             for header in splitted_headers:
5.19 async_server.py(139):                 if ':' in header:
5.19 async_server.py(140):                     splitted_header = header.split(":", 1)
5.19 async_server.py(141):                     if len(splitted_header) > 1:
5.19 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
5.19 async_server.py(138):             for header in splitted_headers:
5.19 async_server.py(139):                 if ':' in header:
5.19 async_server.py(140):                     splitted_header = header.split(":", 1)
5.19 async_server.py(141):                     if len(splitted_header) > 1:
5.19 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
5.19 async_server.py(138):             for header in splitted_headers:
5.19 async_server.py(139):                 if ':' in header:
5.19 async_server.py(140):                     splitted_header = header.split(":", 1)
5.19 async_server.py(141):                     if len(splitted_header) > 1:
5.19 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
5.19 async_server.py(138):             for header in splitted_headers:
5.19 async_server.py(139):                 if ':' in header:
5.19 async_server.py(140):                     splitted_header = header.split(":", 1)
5.20 async_server.py(141):                     if len(splitted_header) > 1:
5.20 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
5.20 async_server.py(138):             for header in splitted_headers:
5.20 async_server.py(139):                 if ':' in header:
5.20 async_server.py(140):                     splitted_header = header.split(":", 1)
5.20 async_server.py(141):                     if len(splitted_header) > 1:
5.20 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
5.20 async_server.py(138):             for header in splitted_headers:
5.20 async_server.py(139):                 if ':' in header:
5.20 async_server.py(138):             for header in splitted_headers:
5.20 async_server.py(139):                 if ':' in header:
5.20 async_server.py(138):             for header in splitted_headers:
5.20 async_server.py(149):         if method == 'GET':
5.20 async_server.py(150):             logging.info('Request method is GET')
5.20 async_server.py(205):         if '?' in path:
5.20 async_server.py(213):         logging.info('Converting path: {} to Path object...'.format(path))
5.20 async_server.py(214):         path = convert_path(path)
5.20 async_server.py(454):     if isinstance(path, str):
5.20 async_server.py(455):         return Path("./{path}".format(path=path))
5.20 async_server.py(215):         if path.exists():
5.20 async_server.py(216):             path_str = str(path)
5.20 async_server.py(217):             logging.info('Checking if {} is forbidden...'.format(path_str))
5.20 async_server.py(218):             path_is_allowed = False
5.20 async_server.py(219):             for p in env.allowed_dirs:
5.20 async_server.py(220):                 if path_str.startswith(p):
5.20 async_server.py(221):                     path_is_allowed = True
5.20 async_server.py(222):                     break
5.20 async_server.py(223):             if not path_is_allowed:      
5.20 async_server.py(228):             if path_is_allowed:        
5.20 async_server.py(229):                 if path.is_file() or path.is_dir():
5.20 async_server.py(230):                     if path.is_dir():
5.20 async_server.py(244):                     if path.is_file():
5.20 async_server.py(245):                         logging.info('Path is a file')
5.20 async_server.py(246):                         if path_str.startswith("cgi-bin") and os.access(path_str, os.X_OK):
5.20 async_server.py(379):                             logging.info('Path is a resource. Guessing MIME type...')
5.20 async_server.py(380):                             try:
5.20 async_server.py(381):                                 mime = mimetypes.guess_type(path_str, False)[0]
5.20 async_server.py(382):                                 if mime == None:
5.20 async_server.py(388):                             logging.info('MIME: {}'.format(mime))
5.20 async_server.py(398):                                             + b"\r\n\r\n"
5.20 async_server.py(472):     now = datetime.datetime.now()
5.20 async_server.py(473):     stamp = mktime(now.timetuple())
5.20 async_server.py(474):     return format_date_time(stamp).encode()
5.20 async_server.py(482):     return os.environ.get('SERVER_SOFTWARE', "Velioo's Webserver").encode()
5.20 async_server.py(400):                             logging.info('Response:\n{}'.format(http_response.decode()))
5.20 async_server.py(401):                             client_writer.write(http_response)
5.20 async_server.py(402):                             try:
5.20 async_server.py(403):                                 await send_static_file(path, client_writer)
5.20 async_server.py(441):     timeout = time.time() + 10
5.20 async_server.py(442):     async with aiofiles.open(path, 'rb') as f:
5.21 async_server.py(443):         while True:
5.21 async_server.py(444):             chunk = await f.read(env.FILE_CHUNK)
6.50 async_server.py(82):                 try:
6.50 async_server.py(83):                     if time.time() > timeout:
6.50 async_server.py(89):                 if data != b'':
6.50 async_server.py(90):                     logging.info('Data read: {}'.format(data))
6.51 async_server.py(91):                     try:
6.51 async_server.py(92):                         request_headers+=data
6.51 async_server.py(98):                     try:
6.51 async_server.py(99):                         if b'\r\n' in request_headers and not method:
6.51 async_server.py(100):                             method, path, protocol = request_headers.split(b'\r\n')[0].decode('utf-8').strip().split(" ")
6.51 async_server.py(101):                         if b'\r\n\r\n' in request_headers:
6.51 async_server.py(102):                             temp = request_headers
6.51 async_server.py(103):                             request_headers = request_headers.split(b'\r\n\r\n')[0].decode('utf-8') + '\r\n\r\n'
6.51 async_server.py(104):                             if method == 'POST':
6.51 async_server.py(111):                             break
6.51 async_server.py(126):         logging.info('Request headers:\n{}'.format(request_headers))
6.51 async_server.py(127):         if request_headers == b'':
6.51 async_server.py(131):         if '\r\n\r\n' not in request_headers:
6.51 async_server.py(135):         headers = {}
6.51 async_server.py(136):         try:
6.51 async_server.py(137):             splitted_headers = request_headers.split('\r\n')
6.51 async_server.py(138):             for header in splitted_headers:
6.51 async_server.py(139):                 if ':' in header:
6.51 async_server.py(138):             for header in splitted_headers:
6.51 async_server.py(139):                 if ':' in header:
6.51 async_server.py(140):                     splitted_header = header.split(":", 1)
6.51 async_server.py(141):                     if len(splitted_header) > 1:
6.51 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
6.51 async_server.py(138):             for header in splitted_headers:
6.51 async_server.py(139):                 if ':' in header:
6.51 async_server.py(140):                     splitted_header = header.split(":", 1)
6.51 async_server.py(141):                     if len(splitted_header) > 1:
6.51 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
6.51 async_server.py(138):             for header in splitted_headers:
6.51 async_server.py(139):                 if ':' in header:
6.51 async_server.py(140):                     splitted_header = header.split(":", 1)
6.51 async_server.py(141):                     if len(splitted_header) > 1:
6.51 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
6.51 async_server.py(138):             for header in splitted_headers:
6.51 async_server.py(139):                 if ':' in header:
6.51 async_server.py(140):                     splitted_header = header.split(":", 1)
6.51 async_server.py(141):                     if len(splitted_header) > 1:
6.51 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
6.51 async_server.py(138):             for header in splitted_headers:
6.51 async_server.py(139):                 if ':' in header:
6.51 async_server.py(140):                     splitted_header = header.split(":", 1)
6.51 async_server.py(141):                     if len(splitted_header) > 1:
6.51 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
6.51 async_server.py(138):             for header in splitted_headers:
6.51 async_server.py(139):                 if ':' in header:
6.51 async_server.py(140):                     splitted_header = header.split(":", 1)
6.51 async_server.py(141):                     if len(splitted_header) > 1:
6.51 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
6.51 async_server.py(138):             for header in splitted_headers:
6.51 async_server.py(139):                 if ':' in header:
6.51 async_server.py(140):                     splitted_header = header.split(":", 1)
6.51 async_server.py(141):                     if len(splitted_header) > 1:
6.51 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
6.51 async_server.py(138):             for header in splitted_headers:
6.51 async_server.py(139):                 if ':' in header:
6.51 async_server.py(140):                     splitted_header = header.split(":", 1)
6.51 async_server.py(141):                     if len(splitted_header) > 1:
6.51 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
6.51 async_server.py(138):             for header in splitted_headers:
6.51 async_server.py(139):                 if ':' in header:
6.51 async_server.py(140):                     splitted_header = header.split(":", 1)
6.51 async_server.py(141):                     if len(splitted_header) > 1:
6.51 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
6.51 async_server.py(138):             for header in splitted_headers:
6.51 async_server.py(139):                 if ':' in header:
6.51 async_server.py(138):             for header in splitted_headers:
6.51 async_server.py(139):                 if ':' in header:
6.51 async_server.py(138):             for header in splitted_headers:
6.51 async_server.py(149):         if method == 'GET':
6.51 async_server.py(150):             logging.info('Request method is GET')
6.51 async_server.py(205):         if '?' in path:
6.51 async_server.py(213):         logging.info('Converting path: {} to Path object...'.format(path))
6.51 async_server.py(214):         path = convert_path(path)
6.51 async_server.py(454):     if isinstance(path, str):
6.51 async_server.py(455):         return Path("./{path}".format(path=path))
6.51 async_server.py(215):         if path.exists():
6.51 async_server.py(216):             path_str = str(path)
6.51 async_server.py(217):             logging.info('Checking if {} is forbidden...'.format(path_str))
6.51 async_server.py(218):             path_is_allowed = False
6.51 async_server.py(219):             for p in env.allowed_dirs:
6.51 async_server.py(220):                 if path_str.startswith(p):
6.51 async_server.py(221):                     path_is_allowed = True
6.51 async_server.py(222):                     break
6.51 async_server.py(223):             if not path_is_allowed:      
6.51 async_server.py(228):             if path_is_allowed:        
6.51 async_server.py(229):                 if path.is_file() or path.is_dir():
6.51 async_server.py(230):                     if path.is_dir():
6.51 async_server.py(231):                         try:
6.51 async_server.py(232):                             path = convert_path(path_str + "/index.html")
6.51 async_server.py(454):     if isinstance(path, str):
6.51 async_server.py(455):         return Path("./{path}".format(path=path))
6.51 async_server.py(242):                         path_str = str(path)
6.51 async_server.py(243):                         logging.info('Path is a directory. Changing path to {}'.format(path))
6.51 async_server.py(244):                     if path.is_file():
6.51 async_server.py(245):                         logging.info('Path is a file')
6.51 async_server.py(246):                         if path_str.startswith("cgi-bin") and os.access(path_str, os.X_OK):
6.51 async_server.py(379):                             logging.info('Path is a resource. Guessing MIME type...')
6.51 async_server.py(380):                             try:
6.51 async_server.py(381):                                 mime = mimetypes.guess_type(path_str, False)[0]
6.51 async_server.py(382):                                 if mime == None:
6.51 async_server.py(388):                             logging.info('MIME: {}'.format(mime))
6.51 async_server.py(398):                                             + b"\r\n\r\n"
6.51 async_server.py(472):     now = datetime.datetime.now()
6.51 async_server.py(473):     stamp = mktime(now.timetuple())
6.51 async_server.py(474):     return format_date_time(stamp).encode()
6.51 async_server.py(482):     return os.environ.get('SERVER_SOFTWARE', "Velioo's Webserver").encode()
6.51 async_server.py(400):                             logging.info('Response:\n{}'.format(http_response.decode()))
6.51 async_server.py(401):                             client_writer.write(http_response)
6.51 async_server.py(402):                             try:
6.51 async_server.py(403):                                 await send_static_file(path, client_writer)
6.51 async_server.py(441):     timeout = time.time() + 10
6.51 async_server.py(442):     async with aiofiles.open(path, 'rb') as f:
6.53 async_server.py(443):         while True:
6.53 async_server.py(444):             chunk = await f.read(env.FILE_CHUNK)
6.54 async_server.py(445):             if not chunk:
6.54 async_server.py(447):             client_writer.write(chunk)
6.54 async_server.py(448):             await client_writer.drain()
6.54 async_server.py(449):             if time.time() > timeout:
6.54 async_server.py(444):             chunk = await f.read(env.FILE_CHUNK)
6.55 async_server.py(445):             if not chunk:
6.55 async_server.py(446):                 break
6.56 async_server.py(406):                             client_writer.close()
6.58 async_server.py(82):                 try:
6.58 async_server.py(83):                     if time.time() > timeout:
6.58 async_server.py(89):                 if data != b'':
6.58 async_server.py(90):                     logging.info('Data read: {}'.format(data))
6.58 async_server.py(91):                     try:
6.58 async_server.py(92):                         request_headers+=data
6.58 async_server.py(98):                     try:
6.58 async_server.py(99):                         if b'\r\n' in request_headers and not method:
6.58 async_server.py(100):                             method, path, protocol = request_headers.split(b'\r\n')[0].decode('utf-8').strip().split(" ")
6.58 async_server.py(101):                         if b'\r\n\r\n' in request_headers:
6.58 async_server.py(102):                             temp = request_headers
6.58 async_server.py(103):                             request_headers = request_headers.split(b'\r\n\r\n')[0].decode('utf-8') + '\r\n\r\n'
6.58 async_server.py(104):                             if method == 'POST':
6.59 async_server.py(111):                             break
6.59 async_server.py(126):         logging.info('Request headers:\n{}'.format(request_headers))
6.59 async_server.py(127):         if request_headers == b'':
6.59 async_server.py(131):         if '\r\n\r\n' not in request_headers:
6.59 async_server.py(135):         headers = {}
6.59 async_server.py(136):         try:
6.59 async_server.py(137):             splitted_headers = request_headers.split('\r\n')
6.59 async_server.py(138):             for header in splitted_headers:
6.59 async_server.py(139):                 if ':' in header:
6.59 async_server.py(138):             for header in splitted_headers:
6.59 async_server.py(139):                 if ':' in header:
6.59 async_server.py(140):                     splitted_header = header.split(":", 1)
6.59 async_server.py(141):                     if len(splitted_header) > 1:
6.59 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
6.59 async_server.py(138):             for header in splitted_headers:
6.59 async_server.py(139):                 if ':' in header:
6.59 async_server.py(140):                     splitted_header = header.split(":", 1)
6.59 async_server.py(141):                     if len(splitted_header) > 1:
6.59 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
6.59 async_server.py(138):             for header in splitted_headers:
6.59 async_server.py(139):                 if ':' in header:
6.59 async_server.py(140):                     splitted_header = header.split(":", 1)
6.59 async_server.py(141):                     if len(splitted_header) > 1:
6.59 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
6.59 async_server.py(138):             for header in splitted_headers:
6.59 async_server.py(139):                 if ':' in header:
6.59 async_server.py(140):                     splitted_header = header.split(":", 1)
6.59 async_server.py(141):                     if len(splitted_header) > 1:
6.59 async_server.py(142):                         headers[splitted_header[0].strip().rstrip()] = splitted_header[1].strip().rstrip()
6.59 async_server.py(138):             for header in splitted_headers:
6.59 async_server.py(139):                 if ':' in header:
6.59 async_server.py(140):                     splitte